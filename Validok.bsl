
#Область ПрограммныйИнтерфейс

Функция Валидация(Знач Шаблон, Знач Данные, ИмяОбъектаВерхнегоУровня = "") Экспорт

	ПроверитьВходныеПараметрыФункции(Шаблон, Данные);
	
	СтруктураВозврата = СтандартнаяСтруктураВозврата();
	
	// Проверим наличие лишних полев во входных данных
	Стр = ПроверитьНаличиеЛишнихПолей(Шаблон, Данные, ИмяОбъектаВерхнегоУровня);
	ДополнитьСтруктуру(СтруктураВозврата.ОшибкиВалидации, Стр.ОшибкиВалидации);
	
	// Согласно шаблону валидации проверяем входные данные
	
	Для каждого ОписаниеПоля Из Шаблон Цикл
		
		Имя = ОписаниеПоля["Имя"];
		Значение = Данные[Имя];
		
		Обязательность = ОписаниеПоля["Обязательность"];
		ТипЗначенияОжидаемый = Тип(ОписаниеПоля["Тип"]);
		ТипЗначенияДанных = ТипЗнч(Значение);
		
		// Если поле не обязательно и не задано, пропускаем все остальные проверки
		Если НЕ Обязательность И Значение = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		// Проверим данные на соответствие их типа типу, описанному в шаблоне
		Если Значение <> Неопределено И ТипЗначенияДанных <> ТипЗначенияОжидаемый Тогда
				
			СтруктураВозврата.ВалидацияПройдена = Ложь;
				
			СтруктураВозврата.ОшибкиВалидации.Вставить(?(ПустаяСтрока(ИмяОбъектаВерхнегоУровня), "", ИмяОбъектаВерхнегоУровня + ".") + Имя,
				ПодставитьПараметрыВСтроку(ЛокализованнаяСтрока("ВалидацииЗначениеДолжноБытьТипа"), ТипЗначенияОжидаемый));
			Продолжить;
			
		КонецЕсли;
	
		// Проверим обязательные данные на заполенность. Данная проверка
		// не простая, в том смысле что для свойств, для которых имеет смысл
		// понятие "размер" (как Число, Массив, Строка) полное отсутствие
		// содержимого является нарушением только если указано дополнительное
		// свойство нижней границы и это ограничение - больше нуля.
		// То есть, если тип значения Число и указано МинимальноеЗначение = 0,
		// тогда "НЕ ЗначениеЗаполнено(Значение)" даст истину, хотя это не
		// является нарушением. То же для строки "МинимальнаяДлина" и для
		// массивов "МинимальныйРазмер". Поэтому проверка комплексная.
		
		Если НЕ ЗначениеЗаполнено(Значение) Тогда
			
			РазрешеноПустоеЗначениеТипа = Ложь;
			
			Если ТипЗначенияДанных = Тип("Строка")
				И ОписаниеПоля["МинимальнаяДлина"] <> Неопределено
				И ОписаниеПоля["МинимальнаяДлина"] = 0 Тогда
				
				РазрешеноПустоеЗначениеТипа = Истина;
				
			КонецЕсли;
			
			Если ТипЗначенияДанных = Тип("Число")
				И ОписаниеПоля["МинимальноеЗначение"] <> Неопределено
				И ОписаниеПоля["МинимальноеЗначение"] = 0 Тогда
				
				РазрешеноПустоеЗначениеТипа = Истина;
				
			КонецЕсли;
			
			Если ТипЗначенияДанных = Тип("Массив")
				И ОписаниеПоля["МинимальныйРазмер"] <> Неопределено
				И ОписаниеПоля["МинимальныйРазмер"] = 0 Тогда
				
				РазрешеноПустоеЗначениеТипа = Истина;
				
			КонецЕсли;
			
			Если Обязательность И НЕ РазрешеноПустоеЗначениеТипа Тогда

				СтруктураВозврата.ВалидацияПройдена = Ложь;
				
				СтруктураВозврата.ОшибкиВалидации.Вставить(?(ПустаяСтрока(ИмяОбъектаВерхнегоУровня), "", ИмяОбъектаВерхнегоУровня + ".") + Имя,
					ЛокализованнаяСтрока("ВалидацииЗначениеДолжноБытьЗадано"));
					
				Продолжить;
						
			КонецЕсли;
			
		КонецЕсли;
		
		// Для данных типа Число проверим выход за границы
		// диапазона, если диапазон задан
		Если ТипЗначенияОжидаемый = Тип("Число") Тогда
			
			ВыходЧисловогоЗначенияЗаПределы = Ложь;
			
			Если ОписаниеПоля["МинимальноеЗначение"] <> Неопределено И Значение < ОписаниеПоля["МинимальноеЗначение"] Тогда
				
				СтруктураВозврата.ОшибкиВалидации.Вставить(?(ПустаяСтрока(ИмяОбъектаВерхнегоУровня), "", ИмяОбъектаВерхнегоУровня + ".") + Имя,
					ПодставитьПараметрыВСтроку(ЛокализованнаяСтрока("ВалидацииЗначениеДолжноБытьБольшеИлиРавно"), ОписаниеПоля["МинимальноеЗначение"]));
					
				ВыходЧисловогоЗначенияЗаПределы = Истина;
				
			КонецЕсли;
			
			Если ОписаниеПоля["МаксимальноеЗначение"] <> Неопределено И Значение > ОписаниеПоля["МаксимальноеЗначение"] Тогда
				
				СтруктураВозврата.ОшибкиВалидации.Вставить(?(ПустаяСтрока(ИмяОбъектаВерхнегоУровня), "", ИмяОбъектаВерхнегоУровня + ".") + Имя,
					ПодставитьПараметрыВСтроку(ЛокализованнаяСтрока("ВалидацииЗначениеДолжноБытьМеньшеИлиРавно"), ОписаниеПоля["МинимальноеЗначение"]));
					
				ВыходЧисловогоЗначенияЗаПределы = Истина;
				
			КонецЕсли;
			
			Если ВыходЧисловогоЗначенияЗаПределы Тогда
				СтруктураВозврата.ВалидацияПройдена = Ложь;
			КонецЕсли;
			
		КонецЕсли;
		
		// Для данных типа Строка проверим на
		// соответствие ограничению длинны, если задано
		Если ТипЗначенияОжидаемый = Тип("Строка") Тогда
			
			ВыходДлыныСтрокиЗаПределы = Ложь;
	
			Если ОписаниеПоля["МинимальнаяДлина"] <> Неопределено И СтрДлина(Значение) < ОписаниеПоля["МинимальнаяДлина"] Тогда
				
				СтруктураВозврата.ОшибкиВалидации.Вставить(?(ПустаяСтрока(ИмяОбъектаВерхнегоУровня), "", ИмяОбъектаВерхнегоУровня + ".") + Имя,
					ПодставитьПараметрыВСтроку(ЛокализованнаяСтрока("ВалидацииДлинаСтрокиДолжнаБытьБольшеИлиРавна"), ОписаниеПоля["МинимальнаяДлина"]));
					
				ВыходДлыныСтрокиЗаПределы = Истина;
				
			КонецЕсли;
			
			Если ОписаниеПоля["МаксимальнаяДлина"] <> Неопределено И СтрДлина(Значение) > ОписаниеПоля["МаксимальнаяДлина"] Тогда
				
				СтруктураВозврата.ОшибкиВалидации.Вставить(?(ПустаяСтрока(ИмяОбъектаВерхнегоУровня), "", ИмяОбъектаВерхнегоУровня + ".") + Имя,
					ПодставитьПараметрыВСтроку(ЛокализованнаяСтрока("ВалидацииДлинаСтрокиДолжнаБытьМеньшеИлиРавна"), ОписаниеПоля["МаксимальнаяДлина"]));
					
				ВыходДлыныСтрокиЗаПределы = Истина;
				
			КонецЕсли;
			
			Если ВыходДлыныСтрокиЗаПределы Тогда
				СтруктураВозврата.ВалидацияПройдена = Ложь;
			КонецЕсли;
			
		КонецЕсли;
		
		// Для данных составного типа (Соответствие) проверми
		// сами данные по вложенному шаблону, если он задан
		Если ТипЗначенияОжидаемый = Тип("Соответствие") И ОписаниеПоля["Шаблон"] <> Неопределено Тогда
			
			РезультатВалидацииСоставногоОбъекта = Валидация(ОписаниеПоля["Шаблон"], Значение, ?(ПустаяСтрока(ИмяОбъектаВерхнегоУровня), "", ИмяОбъектаВерхнегоУровня + ".") + Имя);
			
			Если НЕ РезультатВалидацииСоставногоОбъекта.ВалидацияПройдена Тогда
				
				СтруктураВозврата.ВалидацияПройдена = Ложь;
				
				Для каждого КЗ Из РезультатВалидацииСоставногоОбъекта.ОшибкиВалидации Цикл
					СтруктураВозврата.ОшибкиВалидации.Вставить(КЗ.Ключ, КЗ.Значение);
				КонецЦикла;
					
			КонецЕсли;
			
		КонецЕсли;
		
		// Для данных типа Массива - проверим каждый элемент массива, если
		// задан шаблон элемента
		ШаблонЭлементаМассива = ОписаниеПоля["ШаблонЭлементаМассива"];
		
		Если ТипЗначенияОжидаемый = Тип("Массив") И ШаблонЭлементаМассива <> Неопределено Тогда
				
			// Для поля типа Массив с заданным шаблоном валидации элемента,
			// валидуем каждый элемент массива согласно этому шаблону. Отличие
			// шаблона для массива от шаблона для соответствия в том что в
			// шаблоне элемента массива нет привычного ключа "Имя" так как у
			// элементов массива нет имен. Поэтому прежде чем рекурсивно
			// вызвать функцию для каждого элемента массива - создадим два
			// объект-соответсвия: ШаблонЭлементаМассива и ЗначениеЭлементаМассива,
			// которым придадим форму, пригодную для последующей передавчи в
			// функцию валидации.
			
			Для Индекс = 0 По Значение.ВГраница() Цикл
				
				ЗначениеЭлементаМассива = Новый Соответствие;
				
				// Тут создаем "подсавной" объект типа Соответствие
				// с именем в виде строчного представления индекса
				ЗначениеЭлементаМассива.Вставить(Строка(Индекс), Значение[Индекс]);
				
				// Тут создаем "подставной" шаблон для проверки
				// объекта ЗначениеЭлементаМассива
				ШаблонЭлементаМассива.Вставить("Имя", Строка(Индекс));
				ШаблонЭлементаМассива.Вставить("Обязательность", Истина);
				ШаблонЭлемента = Новый Массив();
				ШаблонЭлемента.Добавить(ШаблонЭлементаМассива);
				
				РезультатВалидацииЭлемента = Валидация(ШаблонЭлемента, ЗначениеЭлементаМассива, ?(ПустаяСтрока(ИмяОбъектаВерхнегоУровня), "", ИмяОбъектаВерхнегоУровня + ".") + Имя);
				
				Если НЕ РезультатВалидацииЭлемента.ВалидацияПройдена Тогда
					
					СтруктураВозврата.ВалидацияПройдена = Ложь;
					
					Для каждого КЗ Из РезультатВалидацииЭлемента.ОшибкиВалидации Цикл
						СтруктураВозврата.ОшибкиВалидации.Вставить(КЗ.Ключ, КЗ.Значение);
					КонецЦикла;
						
				КонецЕсли;
			
			КонецЦикла;
		
		КонецЕсли;
		
	КонецЦикла;
		
	Возврат СтруктураВозврата;
	
КонецФункции

Функция СериализацияВJson(Объект, ПереносСтрокJSON = Неопределено) Экспорт

	ЗаписьJson = Новый ЗаписьJSON();
	ЗаписьJson.УстановитьСтроку(Новый ПараметрыЗаписиJSON(?(ПереносСтрокJSON = Неопределено, ПереносСтрокJSON.Нет, ПереносСтрокJSON), Символы.Таб));
	
	Попытка
		ЗаписатьJSON(ЗаписьJson, Объект);
	Исключение
		
		ЗаписьJson.Закрыть();
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		ВызватьИсключение
			ЛокализованнаяСтрока("СериализацииВJson") +
			": " + ИнформациюОбОшибкеВСтроку(ИнформацияОбОшибке);
		
	КонецПопытки;
	
	Возврат ЗаписьJson.Закрыть();
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция ПроверитьНаличиеЛишнихПолей(Знач Шаблон, Знач Данные, ИмяОбъектаВерхнегоУровня)

	СтруктураВозврата = СтандартнаяСтруктураВозврата();
	
	ВсеИменаПолей = Новый Массив();
	
	Для каждого ОписаниеПоля Из Шаблон Цикл
		ВсеИменаПолей.Добавить(ОписаниеПоля["Имя"]);
	КонецЦикла;
	
	Для каждого КЗ Из Данные Цикл
		
		ИмяПоляВДанных = КЗ.Ключ;
		
		Если ВсеИменаПолей.Найти(ИмяПоляВДанных) = Неопределено Тогда
				
			СтруктураВозврата.ВалидацияПройдена = Ложь;
			
			СтруктураВозврата.ОшибкиВалидации.Вставить(?(ПустаяСтрока(ИмяОбъектаВерхнегоУровня), "", ИмяОбъектаВерхнегоУровня + ".") + ИмяПоляВДанных,
				ЛокализованнаяСтрока("ВалидацииИзбыточныеДанные"));
					
		КонецЕсли;
		
	КонецЦикла;

	Возврат СтруктураВозврата;
	
КонецФункции

Функция СтандартнаяСтруктураВозврата()
	Возврат Новый Структура("ВалидацияПройдена, ОшибкиВалидации", Истина, Новый Соответствие);
КонецФункции

Функция ПроверитьСтрокуНаСоответствиеРегулярномуВыражению(Строка, РегульярноеВыражение)
	
    Чтение = Новый ЧтениеXML;
	
    Чтение.УстановитьСтроку(
                "<Model xmlns=""http://v8.1c.ru/8.1/xdto"" xmlns:xs=""http://www.w3.org/2001/XMLSchema"" xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xsi:type=""Model"">
                |<package targetNamespace=""sample-my-package"">
                |<valueType name=""testtypes"" base=""xs:string"">
                |<pattern>" + РегульярноеВыражение + "</pattern>
                |</valueType>
                |<objectType name=""TestObj"">
                |<property xmlns:d4p1=""sample-my-package"" name=""TestItem"" type=""d4p1:testtypes""/>
                |</objectType>
                |</package>
                |</Model>");

    Модель = ФабрикаXDTO.ПрочитатьXML(Чтение);
	
    МояФабрикаXDTO = Новый ФабрикаXDTO(Модель);
	
	Пакет = МояФабрикаXDTO.Пакеты.Получить("sample-my-package");
	
	Тест = МояФабрикаXDTO.Создать(Пакет.Получить("TestObj"));

    Попытка
        Тест.TestItem = Строка;
        Возврат Истина
    Исключение
        Возврат Ложь
    КонецПопытки;
    
КонецФункции

Процедура ДополнитьСтруктуру(Приемник, Источник)
	Для каждого КЗ Из Источник Цикл
		Приемник.Вставить(КЗ.Ключ, КЗ.Значение);
	КонецЦикла;
КонецПроцедуры

Функция ПроверитьВходныеПараметрыФункции(Шаблон, Данные)

	ПроверитьПараметрФункции(
		"Валидация",
		"Шаблон",
		Тип("Массив"),
		Шаблон);
	
	ПроверитьПараметрФункции(
		"Валидация",
		"Данные",
		Тип("Соответствие"),
		Данные);
		
	ВсеИменаПолей = Новый Массив();

КонецФункции

// Проверяет соответсвие типа значения заданному типу.
// 
// Проверяет соответствие типа значения в параметре "ЗначениеПараметра" типу,
// переданному в параметре "ТипПараметра". В случае несоответствия генерирует
// исключение.
// 
// Параметры:
//
//		ИмяФункции - Строка - имя функции, параметр которой проверяется
//
//		ИмяПараметра - Строка - имя тестируемого параметра
//
//		ТипПараметра - Тип - объект типа "Тип", которому должен соответствовать
//		тип параметра "ЗначениеПараметра"
//
//		ЗначениеПараметра - произвольный - значение, тип которого проверяется.
//
Процедура ПроверитьПараметрФункции(ИмяФункции, ИмяПараметра, ТипПараметра, ЗначениеПараметра) Экспорт

	// Проверим сперва входный параметры непосредственно этой процедуры.
	
	Если ТипЗнч(ИмяФункции) <> Тип("Строка") Тогда
		
		ВызватьИсключение
			ПодставитьПараметрыВСтроку(
				ЛокализованнаяСтрока("НеверныйТипПараметраФункции"),
				"ПроверитьПараметрФункции",
				"ИмяФункции",
				Тип("Строка"));
			
	КонецЕсли;
	
	Если ТипЗнч(ИмяПараметра) <> Тип("Строка") Тогда
		
		ВызватьИсключение
			ПодставитьПараметрыВСтроку(
				ЛокализованнаяСтрока("НеверныйТипПараметраФункции"),
				"ПроверитьПараметрФункции",
				"ИмяПараметра",
				Тип("Строка"));
			
	КонецЕсли;

	Если ТипЗнч(ТипПараметра) <> Тип("Тип") Тогда
		
		ВызватьИсключение
			ПодставитьПараметрыВСтроку(
				ЛокализованнаяСтрока("НеверныйТипПараметраФункции"),
				"ПроверитьПараметрФункции",
				"ТипПараметра",
				Тип("Тип"));
			
	КонецЕсли;

	// Основная работа процедуры
	
	Если ТипЗнч(ЗначениеПараметра) <> ТипПараметра Тогда
		
		ВызватьИсключение
			ПодставитьПараметрыВСтроку(
				ЛокализованнаяСтрока("НеверныйТипПараметраФункции"),
				ИмяФункции,
				ИмяПараметра,
				ТипПараметра);
			
	КонецЕсли;
	
КонецПроцедуры

Функция ЛокализованнаяСтрока(Ключ)
	
	Структура = Новый Структура;
	
	Структура.Вставить("НеверныйТипПараметраФункции",
		НСтр("en = 'Function parameter ''%1'' - ''%2'' must be of type ''%3''';
		|ru = 'Параметр функции ''%1'' - ''%2'' должен быть типа ''%3''';
		|uk = 'Параметр функції ''%1'' - ''%2'' має бути типу ''%3'''"));

	Структура.Вставить("СериализацииВJson",
		НСтр("en = 'Error serializing object to JSON';
		|ru = 'Ошибка сериализации объекта в JSON';
		|uk = 'Помилка серіалізації об''єкта у JSON'"));
	
	Структура.Вставить("ДесериализацииИзJson",
		НСтр("en = 'Error deserializing object from JSON';
		|ru = 'Ошибка десериализации объекта из JSON';
		|uk = 'Помилка десеріалізації об''єкта з JSON'"));
	
	Структура.Вставить("НеверныйШаблонВалидации",
		НСтр("en = 'Invalid pattern'; ru = 'Неверный шаблон'; uk = 'Некоректний шаблон'"));
	
	Структура.Вставить("ВалидацииЗначениеДолжноБытьЗадано",
		НСтр("en = 'Must be specified'; ru = 'Должно быть задано'; uk = 'Повинно бути задано'"));
	
	Структура.Вставить("ВалидацииЗначениеДолжноБытьТипа",
		НСтр("en = 'Value must be of type ''%1'''; ru = 'Значение должно быть типа ''%1'''; uk = 'Значення має бути типу ''%1'''"));
	
	Структура.Вставить("ВалидацииИзбыточныеДанные",
		НСтр("en = 'Excess data'; ru = 'Лишние данные'; uk = 'Зайві дані'"));
	
	Структура.Вставить("ВалидацииЗначениеДолжноБытьБольшеИлиРавно",
		НСтр("en = 'Value must be greater than or equal to %1';
		|ru = 'Значение должно быть больше или равно %1';
		|uk = 'Значення має бути більшим або дорівнювати %1'"));
	
	Структура.Вставить("ВалидацииЗначениеДолжноБытьМеньшеИлиРавно",
		НСтр("en = 'Value must be less than or equal to %1';
		|ru = 'Значение должно быть меньше или равно %1';
		|uk = 'Значення має бути меншим або дорівнювати %1'"));
	
	Структура.Вставить("ВалидацииДлинаСтрокиДолжнаБытьБольшеИлиРавна",
		НСтр("en = 'String length must be greater than or equal to %1';
		|ru = 'Длина строки должна быть больше или равна %1';
		|uk = 'Довжина рядка має бути більшою або дорівнювати %1'"));
	
	Структура.Вставить("ВалидацииДлинаСтрокиДолжнаБытьМеньшеИлиРавна",
		НСтр("en = 'String length must be less than or equal to %1';
		|ru = 'Длина строки должна быть меньше или равна %1';
		|uk = 'Довжина рядка має бути меншою або дорівнювати %1'"));
		
	Возврат Структура[Ключ];

КонецФункции

Функция ПодставитьПараметрыВСтроку(Знач СтрокаПодстановки,
	Знач Параметр1, Знач Параметр2 = Неопределено, Знач Параметр3 = Неопределено,
	Знач Параметр4 = Неопределено, Знач Параметр5 = Неопределено, Знач Параметр6 = Неопределено,
	Знач Параметр7 = Неопределено, Знач Параметр8 = Неопределено, Знач Параметр9 = Неопределено) Экспорт
	
	ИспользоватьАльтернативныйАлгоритм = 
		Найти(Параметр1, "%")
		Или Найти(Параметр2, "%")
		Или Найти(Параметр3, "%")
		Или Найти(Параметр4, "%")
		Или Найти(Параметр5, "%")
		Или Найти(Параметр6, "%")
		Или Найти(Параметр7, "%")
		Или Найти(Параметр8, "%")
		Или Найти(Параметр9, "%");
		
	Если ИспользоватьАльтернативныйАлгоритм Тогда
		СтрокаПодстановки = ПодставитьПараметрыВСтрокуАльтернативныйАлгоритм(СтрокаПодстановки, Параметр1,
			Параметр2, Параметр3, Параметр4, Параметр5, Параметр6, Параметр7, Параметр8, Параметр9);
	Иначе
		СтрокаПодстановки = СтрЗаменить(СтрокаПодстановки, "%1", Параметр1);
		СтрокаПодстановки = СтрЗаменить(СтрокаПодстановки, "%2", Параметр2);
		СтрокаПодстановки = СтрЗаменить(СтрокаПодстановки, "%3", Параметр3);
		СтрокаПодстановки = СтрЗаменить(СтрокаПодстановки, "%4", Параметр4);
		СтрокаПодстановки = СтрЗаменить(СтрокаПодстановки, "%5", Параметр5);
		СтрокаПодстановки = СтрЗаменить(СтрокаПодстановки, "%6", Параметр6);
		СтрокаПодстановки = СтрЗаменить(СтрокаПодстановки, "%7", Параметр7);
		СтрокаПодстановки = СтрЗаменить(СтрокаПодстановки, "%8", Параметр8);
		СтрокаПодстановки = СтрЗаменить(СтрокаПодстановки, "%9", Параметр9);
	КонецЕсли;
	
	Возврат СтрокаПодстановки;
	
КонецФункции

Функция ПодставитьПараметрыВСтрокуАльтернативныйАлгоритм(Знач СтрокаПодстановки,
	Знач Параметр1, Знач Параметр2 = Неопределено, Знач Параметр3 = Неопределено,
	Знач Параметр4 = Неопределено, Знач Параметр5 = Неопределено, Знач Параметр6 = Неопределено,
	Знач Параметр7 = Неопределено, Знач Параметр8 = Неопределено, Знач Параметр9 = Неопределено)
	
	Результат = "";
	Позиция = Найти(СтрокаПодстановки, "%");
	Пока Позиция > 0 Цикл 
		Результат = Результат + Лев(СтрокаПодстановки, Позиция - 1);
		СимволПослеПроцента = Сред(СтрокаПодстановки, Позиция + 1, 1);
		ПодставляемыйПараметр = "";
		Если СимволПослеПроцента = "1" Тогда
			ПодставляемыйПараметр =  Параметр1;
		ИначеЕсли СимволПослеПроцента = "2" Тогда
			ПодставляемыйПараметр =  Параметр2;
		ИначеЕсли СимволПослеПроцента = "3" Тогда
			ПодставляемыйПараметр =  Параметр3;
		ИначеЕсли СимволПослеПроцента = "4" Тогда
			ПодставляемыйПараметр =  Параметр4;
		ИначеЕсли СимволПослеПроцента = "5" Тогда
			ПодставляемыйПараметр =  Параметр5;
		ИначеЕсли СимволПослеПроцента = "6" Тогда
			ПодставляемыйПараметр =  Параметр6;
		ИначеЕсли СимволПослеПроцента = "7" Тогда
			ПодставляемыйПараметр =  Параметр7
		ИначеЕсли СимволПослеПроцента = "8" Тогда
			ПодставляемыйПараметр =  Параметр8;
		ИначеЕсли СимволПослеПроцента = "9" Тогда
			ПодставляемыйПараметр =  Параметр9;
		КонецЕсли;
		Если ПодставляемыйПараметр = "" Тогда
			Результат = Результат + "%";
			СтрокаПодстановки = Сред(СтрокаПодстановки, Позиция + 1);
		Иначе
			Результат = Результат + ПодставляемыйПараметр;
			СтрокаПодстановки = Сред(СтрокаПодстановки, Позиция + 2);
		КонецЕсли;
		Позиция = Найти(СтрокаПодстановки, "%");
	КонецЦикла;
	Результат = Результат + СтрокаПодстановки;
	
	Возврат Результат;
КонецФункции

Функция ИнформациюОбОшибкеВСтроку(ИнформацияОбОшибке) Экспорт
	
	Описание = ИнформацияОбОшибке.Описание;
	
	Если ИнформацияОбОшибке.Причина <> Неопределено Тогда
		Описание = Описание + " -> " +
		ИнформациюОбОшибкеВСтроку(ИнформацияОбОшибке.Причина);
	КонецЕсли;
	
	Возврат Описание;
	
КонецФункции

#КонецОбласти