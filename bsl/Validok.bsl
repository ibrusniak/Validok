
#Область ПрограммныйИнтерфейс

Функция Валидация(Знач Шаблон, Знач Данные, ИмяОбъектаВерхнегоУровня = "") Экспорт

	ПроверитьВходныеПараметрыФункции(Шаблон, Данные);
	
	СтруктураВозврата = Новый Структура("ВалидацияПройдера, ОшибкиВалидации", Истина, Новый Соответствие);
	
	// Проверим наличие лишних полей во входных данных
	
	ВсеИменаПолей = Новый Массив();
	
	Для каждого ОписаниеПоля Из Шаблон Цикл
		ВсеИменаПолей.Добавить(ОписаниеПоля["Имя"]);
	КонецЦикла;
	
	Для каждого КЗ Из Данные Цикл
		
		ИмяПоляВДанных = КЗ.Ключ;
		
		Если ВсеИменаПолей.Найти(ИмяПоляВДанных) = Неопределено Тогда
				
			СтруктураВозврата.ВалидацияПройдера = Ложь;
			
			СтруктураВозврата.ОшибкиВалидации.Вставить(?(ПустаяСтрока(ИмяОбъектаВерхнегоУровня), "", ИмяОбъектаВерхнегоУровня + ".") + ИмяПоляВДанных,
				ЛокализованнаяСтрока("ВалидацииИзбыточныеДанные"));
					
		КонецЕсли;
		
	КонецЦикла;
	
	// Согласно шаблону валидации проверяем входные данные
	
	Для каждого ОписаниеПоля Из Шаблон Цикл
		
		Имя = ОписаниеПоля["Имя"];
		Значение = Данные[Имя];
		
		Обязательность = ОписаниеПоля["Обязательность"];
		ТипЗначения = Тип(ОписаниеПоля["Тип"]);
		
		// Проверим обязательные данные на заполенность
		
		Если НЕ ЗначениеЗаполнено(Значение) Тогда
			
			Если Обязательность Тогда
				
				СтруктураВозврата.ВалидацияПройдера = Ложь;
				
				СтруктураВозврата.ОшибкиВалидации.Вставить(?(ПустаяСтрока(ИмяОбъектаВерхнегоУровня), "", ИмяОбъектаВерхнегоУровня + ".") + Имя,
					ЛокализованнаяСтрока("ВалидацииЗначениеДолжноБытьЗадано"));
						
			КонецЕсли;
			Продолжить;
			
		КонецЕсли;
		
		// Проверим данные на соответствие их типа типу, описанному в шаблоне
		
		Если ТипЗнч(Значение) <> ТипЗначения Тогда
				
			СтруктураВозврата.ВалидацияПройдера = Ложь;
				
			СтруктураВозврата.ОшибкиВалидации.Вставить(?(ПустаяСтрока(ИмяОбъектаВерхнегоУровня), "", ИмяОбъектаВерхнегоУровня + ".") + Имя,
				ПодставитьПараметрыВСтроку(ЛокализованнаяСтрока("ВалидацииЗначениеДолжноБытьТипа"), ТипЗначения));
			Продолжить;
			
		КонецЕсли;
		
		// Для данных типа Число проверим выход за границы диапазона,
		// если диапазон задан
		
		Если ТипЗначения = Тип("Число") Тогда
			
			ВыходЧисловогоЗначенияЗаПределы = Ложь;
			
			Если ОписаниеПоля["МинимальноеЗначение"] <> Неопределено И Значение <= ОписаниеПоля["МинимальноеЗначение"] Тогда
				
				СтруктураВозврата.ОшибкиВалидации.Вставить(?(ПустаяСтрока(ИмяОбъектаВерхнегоУровня), "", ИмяОбъектаВерхнегоУровня + ".") + Имя,
					ПодставитьПараметрыВСтроку(ЛокализованнаяСтрока("ВалидацииЗначениеДолжноБытьБольше"), ОписаниеПоля["МинимальноеЗначение"]));
					
				ВыходЧисловогоЗначенияЗаПределы = Истина;
				
			КонецЕсли;
			
			Если ОписаниеПоля["МаксимальноеЗначение"] <> Неопределено И Значение >= ОписаниеПоля["МаксимальноеЗначение"] Тогда
				
				СтруктураВозврата.ОшибкиВалидации.Вставить(?(ПустаяСтрока(ИмяОбъектаВерхнегоУровня), "", ИмяОбъектаВерхнегоУровня + ".") + Имя,
					ПодставитьПараметрыВСтроку(ЛокализованнаяСтрока("ВалидацииЗначениеДолжноБытьМеньше"), ОписаниеПоля["МинимальноеЗначение"]));
					
				ВыходЧисловогоЗначенияЗаПределы = Истина;
				
			КонецЕсли;
			
			Если ВыходЧисловогоЗначенияЗаПределы Тогда
				СтруктураВозврата.ВалидацияПройдера = Ложь;
			КонецЕсли;
			
		КонецЕсли;
		
		Если ТипЗначения = Тип("Соответствие") И ОписаниеПоля["Шаблон"] <> Неопределено Тогда
			
			// Для "соcтавных данных", то есть полей типа соответствие, в случае
			// когда задан также подшаблон (поле "шаблон") - рекурсивно проверяем
			// и сам составной объект согласно этому подшаблону.
			
			РезультатВалидацииСоставногоОбъекта = Валидация(ОписаниеПоля["Шаблон"], Значение, ?(ПустаяСтрока(ИмяОбъектаВерхнегоУровня), "", ИмяОбъектаВерхнегоУровня + ".") + Имя);
			
			Если НЕ РезультатВалидацииСоставногоОбъекта.ВалидацияПройдера Тогда
				
				СтруктураВозврата.ВалидацияПройдера = Ложь;
				
				Для каждого КЗ Из РезультатВалидацииСоставногоОбъекта.ОшибкиВалидации Цикл
					СтруктураВозврата.ОшибкиВалидации.Вставить(КЗ.Ключ, КЗ.Значение);
				КонецЦикла;
					
			КонецЕсли;
			
		КонецЕсли;
		
		ШаблонЭлементаМассива = ОписаниеПоля["ШаблонЭлементаМассива"];
		
		Если ТипЗначения = Тип("Массив") И ШаблонЭлементаМассива <> Неопределено Тогда
				
			// Для поля типа Массив с заданным шаблоном валидации элемента,
			// валидуем каждый элемент массива согласно этому шаблону. Отличие
			// шаблона для массива от шаблона для соответствия в том что в
			// шаблоне элемента массива нет привычного ключа "Имя" так как у
			// элементов массива нет имен. Поэтому прежде чем рекурсивно
			// вызвать функцию для каждого элемента массива - создадим два
			// объект-соответсвия: ШаблонЭлементаМассива и ЗначениеЭлементаМассива,
			// которым придадим форму, пригодную для последующей передавчи в
			// функцию валидации.
			
			Для Индекс = 0 По Значение.ВГраница() Цикл
				
				ЗначениеЭлементаМассива = Новый Соответствие;
				
				// Тут создаем "подсавной" объект типа Соответствие
				// с именем в виде строчного представления индекса
				ЗначениеЭлементаМассива.Вставить(Строка(Индекс), Значение[Индекс]);
				
				// Тут создаем "подставной" шаблон для проверки
				// объекта ЗначениеЭлементаМассива
				ШаблонЭлементаМассива.Вставить("Имя", Строка(Индекс));
				ШаблонЭлементаМассива.Вставить("Обязательность", Истина);
				ШаблонЭлемента = Новый Массив();
				ШаблонЭлемента.Добавить(ШаблонЭлементаМассива);
				
				РезультатВалидацииЭлемента = Валидация(ШаблонЭлемента, ЗначениеЭлементаМассива, ?(ПустаяСтрока(ИмяОбъектаВерхнегоУровня), "", ИмяОбъектаВерхнегоУровня + ".") + Имя);
				
				Если НЕ РезультатВалидацииЭлемента.ВалидацияПройдера Тогда
					
					СтруктураВозврата.ВалидацияПройдера = Ложь;
					
					Для каждого КЗ Из РезультатВалидацииЭлемента.ОшибкиВалидации Цикл
						СтруктураВозврата.ОшибкиВалидации.Вставить(КЗ.Ключ, КЗ.Значение);
					КонецЦикла;
						
				КонецЕсли;
			
			КонецЦикла;
		
		КонецЕсли;
		
	КонецЦикла;
		
	Возврат СтруктураВозврата;
	
КонецФункции

Функция СериализацияВJson(Объект, ПереносСтрокJSON = Неопределено) Экспорт

	ЗаписьJson = Новый ЗаписьJSON();
	ЗаписьJson.УстановитьСтроку(Новый ПараметрыЗаписиJSON(?(ПереносСтрокJSON = Неопределено, ПереносСтрокJSON.Нет, ПереносСтрокJSON), Символы.Таб));
	
	Попытка
		ЗаписатьJSON(ЗаписьJson, Объект);
	Исключение
		
		ЗаписьJson.Закрыть();
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		ВызватьИсключение
			ЛокализованнаяСтрока("СериализацииВJson") +
			": " + ИнформациюОбОшибкеВСтроку(ИнформацияОбОшибке);
		
	КонецПопытки;
	
	Возврат ЗаписьJson.Закрыть();
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция ПроверитьВходныеПараметрыФункции(Шаблон, Данные)

	ПроверитьПараметрФункции(
		"Валидация",
		"Шаблон",
		Тип("Массив"),
		Шаблон);
	
	ПроверитьПараметрФункции(
		"Валидация",
		"Данные",
		Тип("Соответствие"),
		Данные);
		
	ВсеИменаПолей = Новый Массив();

КонецФункции

// Проверяет соответсвие типа значения заданному типу.
// 
// Проверяет соответствие типа значения в параметре "ЗначениеПараметра" типу,
// переданному в параметре "ТипПараметра". В случае несоответствия генерирует
// исключение.
// 
// Параметры:
//
//		ИмяФункции - Строка - имя функции, параметр которой проверяется
//
//		ИмяПараметра - Строка - имя тестируемого параметра
//
//		ТипПараметра - Тип - объект типа "Тип", которому должен соответствовать
//		тип параметра "ЗначениеПараметра"
//
//		ЗначениеПараметра - произвольный - значение, тип которого проверяется.
//
Процедура ПроверитьПараметрФункции(ИмяФункции, ИмяПараметра, ТипПараметра, ЗначениеПараметра) Экспорт

	// Проверим сперва входный параметры непосредственно этой процедуры.
	
	Если ТипЗнч(ИмяФункции) <> Тип("Строка") Тогда
		
		ВызватьИсключение
			ПодставитьПараметрыВСтроку(
				ЛокализованнаяСтрока("НеверныйТипПараметраФункции"),
				"ПроверитьПараметрФункции",
				"ИмяФункции",
				Тип("Строка"));
			
	КонецЕсли;
	
	Если ТипЗнч(ИмяПараметра) <> Тип("Строка") Тогда
		
		ВызватьИсключение
			ПодставитьПараметрыВСтроку(
				ЛокализованнаяСтрока("НеверныйТипПараметраФункции"),
				"ПроверитьПараметрФункции",
				"ИмяПараметра",
				Тип("Строка"));
			
	КонецЕсли;

	Если ТипЗнч(ТипПараметра) <> Тип("Тип") Тогда
		
		ВызватьИсключение
			ПодставитьПараметрыВСтроку(
				ЛокализованнаяСтрока("НеверныйТипПараметраФункции"),
				"ПроверитьПараметрФункции",
				"ТипПараметра",
				Тип("Тип"));
			
	КонецЕсли;

	// Основная работа процедуры
	
	Если ТипЗнч(ЗначениеПараметра) <> ТипПараметра Тогда
		
		ВызватьИсключение
			ПодставитьПараметрыВСтроку(
				ЛокализованнаяСтрока("НеверныйТипПараметраФункции"),
				ИмяФункции,
				ИмяПараметра,
				ТипПараметра);
			
	КонецЕсли;
	
КонецПроцедуры

Функция ЛокализованнаяСтрока(Ключ)
	
	Структура = Новый Структура;
	
	Структура.Вставить("НеверныйТипПараметраФункции",
		НСтр("en = 'Function parameter ''%1'' - ''%2'' must be of type ''%3''';
		|ru = 'Параметр функции ''%1'' - ''%2'' должен быть типа ''%3''';
		|uk = 'Параметр функції ''%1'' - ''%2'' має бути типу ''%3'''"));

	Структура.Вставить("СериализацииВJson",
		НСтр("en = 'Error serializing object to JSON';
		|ru = 'Ошибка сериализации объекта в JSON';
		|uk = 'Помилка серіалізації об''єкта у JSON'"));
	
	Структура.Вставить("ДесериализацииИзJson",
		НСтр("en = 'Error deserializing object from JSON';
		|ru = 'Ошибка десериализации объекта из JSON';
		|uk = 'Помилка десеріалізації об''єкта з JSON'"));
	
	Структура.Вставить("НеверныйШаблонВалидации",
		НСтр("en = 'Invalid pattern'; ru = 'Неверный шаблон'; uk = 'Некоректний шаблон'"));
	
	Структура.Вставить("ВалидацииЗначениеДолжноБытьЗадано",
		НСтр("en = 'Must be specified'; ru = 'Должно быть задано'; uk = 'Повинно бути задано'"));
	
	Структура.Вставить("ВалидацииЗначениеДолжноБытьТипа",
		НСтр("en = 'Value must be of type ''%1'''; ru = 'Значение должно быть типа ''%1'''; uk = 'Значення має бути типу ''%1'''"));
	
	Структура.Вставить("ВалидацииИзбыточныеДанные",
		НСтр("en = 'Excess data'; ru = 'Лишние данные'; uk = 'Зайві дані'"));
	
	Структура.Вставить("ВалидацииЗначениеДолжноБытьБольше",
		НСтр("en = 'Value must be greater than ''%1''';
		|ru = 'Значение должно быть больше ''%1''';
		|uk = 'Значення має бути більшим за ''%1'''"));
	
	Структура.Вставить("ВалидацииЗначениеДолжноБытьМеньше",
		НСтр("en = 'Value must be less than ''%1''';
		|ru = 'Значение должно быть меньше ''%1''';
		|uk = 'Значення має бути меншим за ''%1'''"));
		
	Возврат Структура[Ключ];

КонецФункции

Функция ПодставитьПараметрыВСтроку(Знач СтрокаПодстановки,
	Знач Параметр1, Знач Параметр2 = Неопределено, Знач Параметр3 = Неопределено,
	Знач Параметр4 = Неопределено, Знач Параметр5 = Неопределено, Знач Параметр6 = Неопределено,
	Знач Параметр7 = Неопределено, Знач Параметр8 = Неопределено, Знач Параметр9 = Неопределено) Экспорт
	
	ИспользоватьАльтернативныйАлгоритм = 
		Найти(Параметр1, "%")
		Или Найти(Параметр2, "%")
		Или Найти(Параметр3, "%")
		Или Найти(Параметр4, "%")
		Или Найти(Параметр5, "%")
		Или Найти(Параметр6, "%")
		Или Найти(Параметр7, "%")
		Или Найти(Параметр8, "%")
		Или Найти(Параметр9, "%");
		
	Если ИспользоватьАльтернативныйАлгоритм Тогда
		СтрокаПодстановки = ПодставитьПараметрыВСтрокуАльтернативныйАлгоритм(СтрокаПодстановки, Параметр1,
			Параметр2, Параметр3, Параметр4, Параметр5, Параметр6, Параметр7, Параметр8, Параметр9);
	Иначе
		СтрокаПодстановки = СтрЗаменить(СтрокаПодстановки, "%1", Параметр1);
		СтрокаПодстановки = СтрЗаменить(СтрокаПодстановки, "%2", Параметр2);
		СтрокаПодстановки = СтрЗаменить(СтрокаПодстановки, "%3", Параметр3);
		СтрокаПодстановки = СтрЗаменить(СтрокаПодстановки, "%4", Параметр4);
		СтрокаПодстановки = СтрЗаменить(СтрокаПодстановки, "%5", Параметр5);
		СтрокаПодстановки = СтрЗаменить(СтрокаПодстановки, "%6", Параметр6);
		СтрокаПодстановки = СтрЗаменить(СтрокаПодстановки, "%7", Параметр7);
		СтрокаПодстановки = СтрЗаменить(СтрокаПодстановки, "%8", Параметр8);
		СтрокаПодстановки = СтрЗаменить(СтрокаПодстановки, "%9", Параметр9);
	КонецЕсли;
	
	Возврат СтрокаПодстановки;
	
КонецФункции

Функция ПодставитьПараметрыВСтрокуАльтернативныйАлгоритм(Знач СтрокаПодстановки,
	Знач Параметр1, Знач Параметр2 = Неопределено, Знач Параметр3 = Неопределено,
	Знач Параметр4 = Неопределено, Знач Параметр5 = Неопределено, Знач Параметр6 = Неопределено,
	Знач Параметр7 = Неопределено, Знач Параметр8 = Неопределено, Знач Параметр9 = Неопределено)
	
	Результат = "";
	Позиция = Найти(СтрокаПодстановки, "%");
	Пока Позиция > 0 Цикл 
		Результат = Результат + Лев(СтрокаПодстановки, Позиция - 1);
		СимволПослеПроцента = Сред(СтрокаПодстановки, Позиция + 1, 1);
		ПодставляемыйПараметр = "";
		Если СимволПослеПроцента = "1" Тогда
			ПодставляемыйПараметр =  Параметр1;
		ИначеЕсли СимволПослеПроцента = "2" Тогда
			ПодставляемыйПараметр =  Параметр2;
		ИначеЕсли СимволПослеПроцента = "3" Тогда
			ПодставляемыйПараметр =  Параметр3;
		ИначеЕсли СимволПослеПроцента = "4" Тогда
			ПодставляемыйПараметр =  Параметр4;
		ИначеЕсли СимволПослеПроцента = "5" Тогда
			ПодставляемыйПараметр =  Параметр5;
		ИначеЕсли СимволПослеПроцента = "6" Тогда
			ПодставляемыйПараметр =  Параметр6;
		ИначеЕсли СимволПослеПроцента = "7" Тогда
			ПодставляемыйПараметр =  Параметр7
		ИначеЕсли СимволПослеПроцента = "8" Тогда
			ПодставляемыйПараметр =  Параметр8;
		ИначеЕсли СимволПослеПроцента = "9" Тогда
			ПодставляемыйПараметр =  Параметр9;
		КонецЕсли;
		Если ПодставляемыйПараметр = "" Тогда
			Результат = Результат + "%";
			СтрокаПодстановки = Сред(СтрокаПодстановки, Позиция + 1);
		Иначе
			Результат = Результат + ПодставляемыйПараметр;
			СтрокаПодстановки = Сред(СтрокаПодстановки, Позиция + 2);
		КонецЕсли;
		Позиция = Найти(СтрокаПодстановки, "%");
	КонецЦикла;
	Результат = Результат + СтрокаПодстановки;
	
	Возврат Результат;
КонецФункции

Функция ИнформациюОбОшибкеВСтроку(ИнформацияОбОшибке) Экспорт
	
	Описание = ИнформацияОбОшибке.Описание;
	
	Если ИнформацияОбОшибке.Причина <> Неопределено Тогда
		Описание = Описание + " -> " +
		ИнформациюОбОшибкеВСтроку(ИнформацияОбОшибке.Причина);
	КонецЕсли;
	
	Возврат Описание;
	
КонецФункции

#КонецОбласти
